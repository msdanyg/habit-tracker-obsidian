/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HabitTrackerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/models/Habit.ts
var DEFAULT_HABIT_DATA = {
  habits: [],
  logs: [],
  categories: [],
  freezeDays: [],
  badges: [],
  version: 2
};
var CATEGORY_COLORS = [
  "#4CAF50",
  // Green
  "#2196F3",
  // Blue
  "#FF9800",
  // Orange
  "#9C27B0",
  // Purple
  "#F44336",
  // Red
  "#00BCD4",
  // Cyan
  "#E91E63",
  // Pink
  "#795548"
  // Brown
];
var BADGE_MILESTONES = [
  { type: "week", days: 7, emoji: "\u{1F525}", label: "First Week" },
  { type: "month", days: 30, emoji: "\u2B50", label: "Monthly Master" },
  { type: "century", days: 100, emoji: "\u{1F48E}", label: "Century Club" },
  { type: "year", days: 365, emoji: "\u{1F451}", label: "Year Champion" }
];
function generateId() {
  return Date.now().toString(36) + Math.random().toString(36).substr(2);
}
function createHabit(name, frequency = "daily", options) {
  return {
    id: generateId(),
    name,
    frequency,
    createdAt: (/* @__PURE__ */ new Date()).toISOString(),
    archived: false,
    order: 0,
    ...options
  };
}
function createHabitLog(habitId, date, completed, note) {
  return {
    date,
    habitId,
    completed,
    note,
    completedAt: completed ? (/* @__PURE__ */ new Date()).toISOString() : void 0
  };
}
function formatDate(date) {
  return date.toISOString().split("T")[0];
}
function isHabitDueOnDate(habit, date) {
  var _a, _b, _c, _d;
  const dayOfWeek = date.getDay();
  switch (habit.frequency) {
    case "daily":
      return true;
    case "weekly":
      return (_b = (_a = habit.customDays) == null ? void 0 : _a.includes(dayOfWeek)) != null ? _b : dayOfWeek === 0;
    case "custom":
      return (_d = (_c = habit.customDays) == null ? void 0 : _c.includes(dayOfWeek)) != null ? _d : false;
  }
}
function createCategory(name, color, options) {
  return {
    id: generateId(),
    name,
    color,
    order: 0,
    ...options
  };
}
function createFreezeDay(date, reason) {
  return {
    date,
    reason
  };
}
function createBadge(habitId, type) {
  return {
    id: generateId(),
    habitId,
    type,
    earnedAt: (/* @__PURE__ */ new Date()).toISOString()
  };
}
function isFrozenDate(date, freezeDays) {
  return freezeDays.some((f) => f.date === date);
}

// src/services/DataService.ts
var DataService = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.data = DEFAULT_HABIT_DATA;
  }
  async load() {
    const savedData = await this.plugin.loadData();
    if (savedData) {
      this.data = {
        ...DEFAULT_HABIT_DATA,
        ...savedData
      };
    }
  }
  async save() {
    await this.plugin.saveData(this.data);
  }
  // Habit CRUD operations
  getHabits(includeArchived = false) {
    const habits = includeArchived ? this.data.habits : this.data.habits.filter((h) => !h.archived);
    return habits.sort((a, b) => a.order - b.order);
  }
  getHabit(id) {
    return this.data.habits.find((h) => h.id === id);
  }
  async addHabit(name, frequency = "daily", options) {
    const maxOrder = Math.max(0, ...this.data.habits.map((h) => h.order));
    const habit = createHabit(name, frequency, { ...options, order: maxOrder + 1 });
    this.data.habits.push(habit);
    await this.save();
    return habit;
  }
  async updateHabit(id, updates) {
    const index = this.data.habits.findIndex((h) => h.id === id);
    if (index === -1)
      return void 0;
    this.data.habits[index] = {
      ...this.data.habits[index],
      ...updates,
      id
      // Prevent id from being changed
    };
    await this.save();
    return this.data.habits[index];
  }
  async deleteHabit(id) {
    const index = this.data.habits.findIndex((h) => h.id === id);
    if (index === -1)
      return false;
    this.data.habits.splice(index, 1);
    this.data.logs = this.data.logs.filter((l) => l.habitId !== id);
    await this.save();
    return true;
  }
  async archiveHabit(id) {
    const habit = await this.updateHabit(id, { archived: true });
    return habit !== void 0;
  }
  async reorderHabits(orderedIds) {
    orderedIds.forEach((id, index) => {
      const habit = this.data.habits.find((h) => h.id === id);
      if (habit) {
        habit.order = index;
      }
    });
    await this.save();
  }
  // Habit Log operations
  getLogs(habitId, startDate, endDate) {
    let logs = this.data.logs;
    if (habitId) {
      logs = logs.filter((l) => l.habitId === habitId);
    }
    if (startDate) {
      logs = logs.filter((l) => l.date >= startDate);
    }
    if (endDate) {
      logs = logs.filter((l) => l.date <= endDate);
    }
    return logs.sort((a, b) => b.date.localeCompare(a.date));
  }
  getLog(habitId, date) {
    return this.data.logs.find((l) => l.habitId === habitId && l.date === date);
  }
  async toggleHabit(habitId, date) {
    const targetDate = date || formatDate(/* @__PURE__ */ new Date());
    const existingLog = this.getLog(habitId, targetDate);
    if (existingLog) {
      existingLog.completed = !existingLog.completed;
      existingLog.completedAt = existingLog.completed ? (/* @__PURE__ */ new Date()).toISOString() : void 0;
      await this.save();
      return existingLog;
    } else {
      const newLog = createHabitLog(habitId, targetDate, true);
      this.data.logs.push(newLog);
      await this.save();
      return newLog;
    }
  }
  async setHabitCompletion(habitId, date, completed, note) {
    const existingLog = this.getLog(habitId, date);
    if (existingLog) {
      existingLog.completed = completed;
      existingLog.note = note;
      existingLog.completedAt = completed ? (/* @__PURE__ */ new Date()).toISOString() : void 0;
      await this.save();
      return existingLog;
    } else {
      const newLog = createHabitLog(habitId, date, completed, note);
      this.data.logs.push(newLog);
      await this.save();
      return newLog;
    }
  }
  // Statistics helpers
  getCompletionRate(habitId, days) {
    const today = /* @__PURE__ */ new Date();
    const startDate = new Date(today);
    startDate.setDate(startDate.getDate() - days + 1);
    const logs = this.getLogs(habitId, formatDate(startDate), formatDate(today));
    const completedCount = logs.filter((l) => l.completed).length;
    return days > 0 ? completedCount / days * 100 : 0;
  }
  getCurrentStreak(habitId) {
    const logs = this.getLogs(habitId).filter((l) => l.completed);
    if (logs.length === 0)
      return 0;
    const habit = this.getHabit(habitId);
    if (!habit)
      return 0;
    let streak = 0;
    const today = /* @__PURE__ */ new Date();
    let currentDate = new Date(today);
    const todayLog = logs.find((l) => l.date === formatDate(today));
    if (!todayLog) {
      currentDate.setDate(currentDate.getDate() - 1);
    }
    while (true) {
      const dateStr = formatDate(currentDate);
      const log = logs.find((l) => l.date === dateStr);
      if (log && log.completed) {
        streak++;
        currentDate.setDate(currentDate.getDate() - 1);
      } else {
        if (habit.frequency === "daily") {
          break;
        } else if (habit.customDays) {
          const dayOfWeek = currentDate.getDay();
          if (habit.customDays.includes(dayOfWeek)) {
            break;
          }
          currentDate.setDate(currentDate.getDate() - 1);
        } else {
          break;
        }
      }
      if (streak > 3650)
        break;
    }
    return streak;
  }
  getLongestStreak(habitId) {
    const logs = this.getLogs(habitId).filter((l) => l.completed).sort((a, b) => a.date.localeCompare(b.date));
    if (logs.length === 0)
      return 0;
    let longestStreak = 1;
    let currentStreak = 1;
    for (let i = 1; i < logs.length; i++) {
      const prevDate = new Date(logs[i - 1].date);
      const currDate = new Date(logs[i].date);
      const diffDays = Math.round(
        (currDate.getTime() - prevDate.getTime()) / (1e3 * 60 * 60 * 24)
      );
      if (diffDays === 1) {
        currentStreak++;
        longestStreak = Math.max(longestStreak, currentStreak);
      } else {
        currentStreak = 1;
      }
    }
    return longestStreak;
  }
  getTotalCompletions(habitId) {
    return this.getLogs(habitId).filter((l) => l.completed).length;
  }
  // ==================== CATEGORY OPERATIONS ====================
  getCategories() {
    return (this.data.categories || []).sort((a, b) => a.order - b.order);
  }
  getCategory(id) {
    var _a;
    return (_a = this.data.categories) == null ? void 0 : _a.find((c) => c.id === id);
  }
  async addCategory(name, color, emoji) {
    if (!this.data.categories)
      this.data.categories = [];
    const maxOrder = Math.max(0, ...this.data.categories.map((c) => c.order));
    const usedColors = this.data.categories.map((c) => c.color);
    const availableColor = color || CATEGORY_COLORS.find((c) => !usedColors.includes(c)) || CATEGORY_COLORS[0];
    const category = createCategory(name, availableColor, { emoji, order: maxOrder + 1 });
    this.data.categories.push(category);
    await this.save();
    return category;
  }
  async updateCategory(id, updates) {
    if (!this.data.categories)
      return void 0;
    const index = this.data.categories.findIndex((c) => c.id === id);
    if (index === -1)
      return void 0;
    this.data.categories[index] = {
      ...this.data.categories[index],
      ...updates,
      id
    };
    await this.save();
    return this.data.categories[index];
  }
  async deleteCategory(id) {
    if (!this.data.categories)
      return false;
    const index = this.data.categories.findIndex((c) => c.id === id);
    if (index === -1)
      return false;
    this.data.categories.splice(index, 1);
    this.data.habits.forEach((h) => {
      if (h.categoryId === id) {
        h.categoryId = void 0;
      }
    });
    await this.save();
    return true;
  }
  getHabitsByCategory(categoryId) {
    const habits = this.getHabits();
    if (categoryId === void 0) {
      return habits.filter((h) => !h.categoryId);
    }
    return habits.filter((h) => h.categoryId === categoryId);
  }
  // ==================== FREEZE DAY OPERATIONS ====================
  getFreezeDays() {
    return this.data.freezeDays || [];
  }
  isFrozen(date) {
    return isFrozenDate(date, this.data.freezeDays || []);
  }
  async addFreezeDay(date, reason) {
    if (!this.data.freezeDays)
      this.data.freezeDays = [];
    if (this.isFrozen(date))
      return null;
    const freezeDay = createFreezeDay(date, reason);
    this.data.freezeDays.push(freezeDay);
    await this.save();
    return freezeDay;
  }
  async removeFreezeDay(date) {
    if (!this.data.freezeDays)
      return false;
    const index = this.data.freezeDays.findIndex((f) => f.date === date);
    if (index === -1)
      return false;
    this.data.freezeDays.splice(index, 1);
    await this.save();
    return true;
  }
  getFreezeDaysThisMonth() {
    const now = /* @__PURE__ */ new Date();
    const monthStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, "0")}`;
    return (this.data.freezeDays || []).filter((f) => f.date.startsWith(monthStr)).length;
  }
  // ==================== BADGE OPERATIONS ====================
  getBadges(habitId) {
    const badges = this.data.badges || [];
    if (habitId) {
      return badges.filter((b) => b.habitId === habitId);
    }
    return badges;
  }
  hasBadge(habitId, type) {
    return (this.data.badges || []).some((b) => b.habitId === habitId && b.type === type);
  }
  async awardBadge(habitId, type) {
    if (!this.data.badges)
      this.data.badges = [];
    if (this.hasBadge(habitId, type))
      return null;
    const badge = createBadge(habitId, type);
    this.data.badges.push(badge);
    await this.save();
    return badge;
  }
  // Check and award badges based on current streak
  async checkAndAwardBadges(habitId) {
    const streak = this.getCurrentStreak(habitId);
    const newBadges = [];
    for (const milestone of BADGE_MILESTONES) {
      if (streak >= milestone.days && !this.hasBadge(habitId, milestone.type)) {
        const badge = await this.awardBadge(habitId, milestone.type);
        if (badge)
          newBadges.push(badge);
      }
    }
    return newBadges;
  }
  getAllBadgesWithDetails() {
    return (this.data.badges || []).map((badge) => ({
      badge,
      habit: this.getHabit(badge.habitId),
      milestone: BADGE_MILESTONES.find((m) => m.type === badge.type)
    }));
  }
  // ==================== ENHANCED STREAK (with freeze support) ====================
  getCurrentStreakWithFreeze(habitId) {
    const logs = this.getLogs(habitId).filter((l) => l.completed);
    if (logs.length === 0)
      return 0;
    const habit = this.getHabit(habitId);
    if (!habit)
      return 0;
    let streak = 0;
    const today = /* @__PURE__ */ new Date();
    let currentDate = new Date(today);
    const todayStr = formatDate(today);
    const todayLog = logs.find((l) => l.date === todayStr);
    const todayFrozen = this.isFrozen(todayStr);
    if (!todayLog && !todayFrozen) {
      currentDate.setDate(currentDate.getDate() - 1);
    }
    while (true) {
      const dateStr = formatDate(currentDate);
      const log = logs.find((l) => l.date === dateStr);
      const frozen = this.isFrozen(dateStr);
      if (frozen) {
        currentDate.setDate(currentDate.getDate() - 1);
        continue;
      }
      if (log && log.completed) {
        streak++;
        currentDate.setDate(currentDate.getDate() - 1);
      } else {
        if (habit.frequency === "daily") {
          break;
        } else if (habit.customDays) {
          const dayOfWeek = currentDate.getDay();
          if (habit.customDays.includes(dayOfWeek)) {
            break;
          }
          currentDate.setDate(currentDate.getDate() - 1);
        } else {
          break;
        }
      }
      if (streak > 3650)
        break;
    }
    return streak;
  }
  // ==================== STATISTICS ====================
  getDayOfWeekStats(habitId, days = 90) {
    const today = /* @__PURE__ */ new Date();
    const startDate = new Date(today);
    startDate.setDate(startDate.getDate() - days + 1);
    const logs = this.getLogs(habitId, formatDate(startDate), formatDate(today));
    const completedLogs = logs.filter((l) => l.completed);
    const dayCounts = [0, 0, 0, 0, 0, 0, 0];
    const dayTotals = [0, 0, 0, 0, 0, 0, 0];
    let date = new Date(startDate);
    while (date <= today) {
      dayTotals[date.getDay()]++;
      date.setDate(date.getDate() + 1);
    }
    completedLogs.forEach((log) => {
      const d = new Date(log.date);
      dayCounts[d.getDay()]++;
    });
    return dayCounts.map((count, i) => dayTotals[i] > 0 ? count / dayTotals[i] * 100 : 0);
  }
  getCompletionTrend(habitId, days = 30) {
    const today = /* @__PURE__ */ new Date();
    const result = [];
    for (let i = days - 1; i >= 0; i--) {
      const date = new Date(today);
      date.setDate(date.getDate() - i);
      const dateStr = formatDate(date);
      const log = this.getLog(habitId, dateStr);
      const frozen = this.isFrozen(dateStr);
      result.push({
        date: dateStr,
        rate: frozen ? -1 : (log == null ? void 0 : log.completed) ? 100 : 0
        // -1 indicates frozen
      });
    }
    return result;
  }
  // ==================== EXPORT/IMPORT ====================
  exportData() {
    return JSON.stringify(this.data, null, 2);
  }
  async importData(jsonString) {
    try {
      const imported = JSON.parse(jsonString);
      if (imported.habits && imported.logs) {
        this.data = {
          ...DEFAULT_HABIT_DATA,
          ...imported
        };
        await this.save();
        return true;
      }
      return false;
    } catch (e) {
      return false;
    }
  }
};

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  showInStatusBar: true,
  defaultView: "today",
  weekStartsOn: 0,
  enableDailyNoteIntegration: false,
  dailyNoteFormat: "## Habits\n{{habits}}",
  showStreakNotifications: true
};
var HabitTrackerSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Habit Tracker Settings" });
    new import_obsidian.Setting(containerEl).setName("Show in status bar").setDesc("Display today's habit progress in the status bar").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showInStatusBar).onChange(async (value) => {
        this.plugin.settings.showInStatusBar = value;
        await this.plugin.saveSettings();
        this.plugin.updateStatusBar();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Default view").setDesc("Which view to show when opening the habit tracker").addDropdown(
      (dropdown) => dropdown.addOption("today", "Today").addOption("calendar", "Calendar").addOption("stats", "Statistics").setValue(this.plugin.settings.defaultView).onChange(async (value) => {
        this.plugin.settings.defaultView = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Week starts on").setDesc("First day of the week for calendar views").addDropdown(
      (dropdown) => dropdown.addOption("0", "Sunday").addOption("1", "Monday").addOption("6", "Saturday").setValue(String(this.plugin.settings.weekStartsOn)).onChange(async (value) => {
        this.plugin.settings.weekStartsOn = parseInt(value);
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Notifications" });
    new import_obsidian.Setting(containerEl).setName("Streak notifications").setDesc("Show notifications for streak milestones (7, 30, 100 days)").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showStreakNotifications).onChange(async (value) => {
        this.plugin.settings.showStreakNotifications = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Daily Note Integration" });
    new import_obsidian.Setting(containerEl).setName("Enable daily note integration").setDesc("Automatically add habit status to your daily notes").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableDailyNoteIntegration).onChange(async (value) => {
        this.plugin.settings.enableDailyNoteIntegration = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Daily note format").setDesc("Template for habit status in daily notes. Use {{habits}} as placeholder.").addTextArea(
      (text) => text.setPlaceholder("## Habits\n{{habits}}").setValue(this.plugin.settings.dailyNoteFormat).onChange(async (value) => {
        this.plugin.settings.dailyNoteFormat = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Data Management" });
    new import_obsidian.Setting(containerEl).setName("Export data").setDesc("Download all your habit data as JSON").addButton(
      (button) => button.setButtonText("Export").onClick(() => {
        const data = this.plugin.dataService.exportData();
        const blob = new Blob([data], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `habit-tracker-backup-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
      })
    );
    new import_obsidian.Setting(containerEl).setName("Import data").setDesc("Restore habit data from a JSON backup (this will replace current data)").addButton(
      (button) => button.setButtonText("Import").onClick(() => {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = ".json";
        input.onchange = async () => {
          var _a;
          const file = (_a = input.files) == null ? void 0 : _a[0];
          if (file) {
            const text = await file.text();
            const success = await this.plugin.dataService.importData(text);
            if (success) {
              this.plugin.refreshViews();
            }
          }
        };
        input.click();
      })
    );
  }
};

// src/views/HabitView.ts
var import_obsidian2 = require("obsidian");
var HABIT_VIEW_TYPE = "habit-tracker-view";
var HABIT_TEMPLATES = {
  morning: {
    name: "\u{1F305} Morning Routine",
    habits: [
      { name: "Wake up early", emoji: "\u23F0" },
      { name: "Drink water", emoji: "\u{1F4A7}" },
      { name: "Stretch/Exercise", emoji: "\u{1F9D8}" },
      { name: "Journal", emoji: "\u{1F4DD}" },
      { name: "Plan the day", emoji: "\u{1F4CB}" },
      { name: "Healthy breakfast", emoji: "\u{1F963}" }
    ]
  },
  fitness: {
    name: "\u{1F4AA} Fitness & Health",
    habits: [
      { name: "Exercise 30min", emoji: "\u{1F3C3}" },
      { name: "10,000 steps", emoji: "\u{1F45F}" },
      { name: "Healthy meals", emoji: "\u{1F957}" },
      { name: "Sleep 7+ hours", emoji: "\u{1F634}" },
      { name: "No alcohol", emoji: "\u{1F6AB}" },
      { name: "Take vitamins", emoji: "\u{1F48A}" }
    ]
  },
  productivity: {
    name: "\u{1F3AF} Productivity",
    habits: [
      { name: "Deep work session", emoji: "\u{1F3AF}" },
      { name: "No social media", emoji: "\u{1F4F5}" },
      { name: "Learn something new", emoji: "\u{1F4DA}" },
      { name: "Review goals", emoji: "\u{1F3AF}" },
      { name: "Inbox zero", emoji: "\u{1F4E7}" }
    ]
  },
  mindfulness: {
    name: "\u{1F9D8} Mindfulness",
    habits: [
      { name: "Meditate", emoji: "\u{1F9D8}" },
      { name: "Gratitude practice", emoji: "\u{1F64F}" },
      { name: "Screen-free hour", emoji: "\u{1F4F4}" },
      { name: "Time in nature", emoji: "\u{1F333}" }
    ]
  },
  learning: {
    name: "\u{1F4DA} Learning",
    habits: [
      { name: "Read 30 minutes", emoji: "\u{1F4D6}" },
      { name: "Practice a skill", emoji: "\u{1F3B8}" },
      { name: "Take notes", emoji: "\u270D\uFE0F" },
      { name: "Teach someone", emoji: "\u{1F468}\u200D\u{1F3EB}" }
    ]
  }
};
var HabitView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.selectedCategoryFilter = null;
    this.selectedHabitForCalendar = null;
    this.plugin = plugin;
    this.currentDate = /* @__PURE__ */ new Date();
    this.currentTab = plugin.settings.defaultView;
  }
  getViewType() {
    return HABIT_VIEW_TYPE;
  }
  getDisplayText() {
    return "Habit Tracker";
  }
  getIcon() {
    return "check-circle";
  }
  async onOpen() {
    this.render();
  }
  async onClose() {
  }
  render() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("habit-tracker-container");
    this.renderHeader(container);
    const content = container.createDiv({ cls: "habit-content" });
    switch (this.currentTab) {
      case "today":
        this.renderTodayView(content);
        break;
      case "calendar":
        this.renderCalendarView(content);
        break;
      case "stats":
        this.renderStatsView(content);
        break;
      case "badges":
        this.renderBadgesView(content);
        break;
    }
  }
  renderHeader(container) {
    const header = container.createDiv({ cls: "habit-header" });
    const tabs = header.createDiv({ cls: "habit-tabs" });
    const tabItems = [
      { key: "today", label: "Today" },
      { key: "calendar", label: "Calendar" },
      { key: "stats", label: "Stats" },
      { key: "badges", label: "Badges" }
    ];
    tabItems.forEach(({ key, label }) => {
      const tab = tabs.createEl("button", {
        cls: `habit-tab ${this.currentTab === key ? "active" : ""}`,
        text: label
      });
      tab.addEventListener("click", () => {
        this.currentTab = key;
        this.render();
      });
    });
    const actions = header.createDiv({ cls: "habit-actions" });
    const templatesBtn = actions.createEl("button", {
      cls: "habit-action-btn",
      text: "\u{1F4E6} Templates"
    });
    templatesBtn.addEventListener("click", () => this.showTemplatesModal());
    const addBtn = actions.createEl("button", {
      cls: "habit-add-btn",
      text: "+ New Habit"
    });
    addBtn.addEventListener("click", () => this.showAddHabitModal());
  }
  renderTodayView(container) {
    const today = /* @__PURE__ */ new Date();
    const dateStr = formatDate(today);
    const isFrozen = this.plugin.dataService.isFrozen(dateStr);
    const dateHeader = container.createDiv({ cls: "habit-date-header" });
    const dateTitle = dateHeader.createDiv({ cls: "date-title-row" });
    dateTitle.createEl("h2", {
      text: today.toLocaleDateString("en-US", {
        weekday: "long",
        month: "long",
        day: "numeric"
      })
    });
    const freezeBtn = dateTitle.createEl("button", {
      cls: `freeze-btn ${isFrozen ? "frozen" : ""}`,
      text: isFrozen ? "\u2744\uFE0F Frozen" : "\u2744\uFE0F Freeze Day"
    });
    freezeBtn.addEventListener("click", async () => {
      if (isFrozen) {
        await this.plugin.dataService.removeFreezeDay(dateStr);
        new import_obsidian2.Notice("Day unfrozen");
      } else {
        const freezesUsed = this.plugin.dataService.getFreezeDaysThisMonth();
        if (freezesUsed >= 2) {
          new import_obsidian2.Notice("You can only freeze 2 days per month");
          return;
        }
        await this.plugin.dataService.addFreezeDay(dateStr, "Rest day");
        new import_obsidian2.Notice("Day frozen! Your streaks are protected.");
      }
      this.render();
    });
    if (isFrozen) {
      container.createEl("div", {
        cls: "frozen-notice",
        text: "\u2744\uFE0F This day is frozen. Habits won't affect your streaks."
      });
    }
    const categories = this.plugin.dataService.getCategories();
    if (categories.length > 0) {
      const filterRow = container.createDiv({ cls: "category-filter-row" });
      filterRow.createEl("span", { text: "Filter: ", cls: "filter-label" });
      const allBtn = filterRow.createEl("button", {
        cls: `category-filter-btn ${this.selectedCategoryFilter === null ? "active" : ""}`,
        text: "All"
      });
      allBtn.addEventListener("click", () => {
        this.selectedCategoryFilter = null;
        this.render();
      });
      categories.forEach((cat) => {
        const btn = filterRow.createEl("button", {
          cls: `category-filter-btn ${this.selectedCategoryFilter === cat.id ? "active" : ""}`,
          text: (cat.emoji || "") + " " + cat.name
        });
        btn.style.setProperty("--cat-color", cat.color);
        btn.addEventListener("click", () => {
          this.selectedCategoryFilter = cat.id;
          this.render();
        });
      });
    }
    let habits = this.plugin.dataService.getHabits();
    if (this.selectedCategoryFilter) {
      habits = habits.filter((h) => h.categoryId === this.selectedCategoryFilter);
    }
    const dueToday = habits.filter((h) => isHabitDueOnDate(h, today));
    const completedToday = dueToday.filter((h) => {
      const log = this.plugin.dataService.getLog(h.id, dateStr);
      return log == null ? void 0 : log.completed;
    });
    const progress = container.createDiv({ cls: "habit-progress" });
    const progressBar = progress.createDiv({ cls: "habit-progress-bar" });
    const percentage = dueToday.length > 0 ? completedToday.length / dueToday.length * 100 : 0;
    progressBar.createDiv({
      cls: "habit-progress-fill",
      attr: { style: `width: ${percentage}%` }
    });
    progress.createEl("span", {
      cls: "habit-progress-text",
      text: `${completedToday.length}/${dueToday.length} completed`
    });
    const habitList = container.createDiv({ cls: "habit-list" });
    if (dueToday.length === 0) {
      habitList.createEl("p", {
        cls: "habit-empty",
        text: "No habits due today. Add a new habit to get started!"
      });
      return;
    }
    const uncategorized = dueToday.filter((h) => !h.categoryId);
    const categorized = /* @__PURE__ */ new Map();
    categories.forEach((cat) => {
      const catHabits = dueToday.filter((h) => h.categoryId === cat.id);
      if (catHabits.length > 0) {
        categorized.set(cat.id, catHabits);
      }
    });
    if (uncategorized.length > 0 && !this.selectedCategoryFilter) {
      uncategorized.forEach((habit) => {
        this.renderHabitItem(habitList, habit, dateStr);
      });
    }
    categorized.forEach((catHabits, catId) => {
      const cat = this.plugin.dataService.getCategory(catId);
      if (!cat)
        return;
      if (!this.selectedCategoryFilter) {
        const catHeader = habitList.createDiv({ cls: "category-header" });
        catHeader.createEl("span", {
          cls: "category-dot",
          attr: { style: `background-color: ${cat.color}` }
        });
        catHeader.createEl("span", { text: (cat.emoji || "") + " " + cat.name });
      }
      catHabits.forEach((habit) => {
        this.renderHabitItem(habitList, habit, dateStr, cat);
      });
    });
  }
  renderHabitItem(container, habit, dateStr, category) {
    var _a;
    const log = this.plugin.dataService.getLog(habit.id, dateStr);
    const isCompleted = (_a = log == null ? void 0 : log.completed) != null ? _a : false;
    const streak = this.plugin.dataService.getCurrentStreakWithFreeze(habit.id);
    const isFrozen = this.plugin.dataService.isFrozen(dateStr);
    const item = container.createDiv({
      cls: `habit-item ${isCompleted ? "completed" : ""} ${isFrozen ? "frozen" : ""}`
    });
    if (category) {
      item.style.setProperty("--habit-accent", category.color);
    }
    const checkbox = item.createDiv({ cls: "habit-checkbox" });
    const checkInput = checkbox.createEl("input", {
      type: "checkbox",
      cls: "habit-checkbox-input"
    });
    if (isCompleted) {
      checkInput.checked = true;
    }
    checkbox.addEventListener("click", async () => {
      const wasCompleted = isCompleted;
      await this.plugin.dataService.toggleHabit(habit.id, dateStr);
      if (!wasCompleted) {
        const newBadges = await this.plugin.dataService.checkAndAwardBadges(habit.id);
        if (newBadges.length > 0) {
          this.showBadgeEarnedAnimation(newBadges[0], habit);
        } else if (this.plugin.settings.showStreakNotifications) {
          this.showCompletionAnimation();
        }
      }
      this.render();
      this.plugin.updateStatusBar();
    });
    const info = item.createDiv({ cls: "habit-info" });
    const nameRow = info.createDiv({ cls: "habit-name-row" });
    const name = nameRow.createDiv({ cls: "habit-name" });
    if (habit.emoji) {
      name.createSpan({ text: habit.emoji + " " });
    }
    name.createSpan({ text: habit.name });
    if (habit.goalDays) {
      const progress = Math.min(100, streak / habit.goalDays * 100);
      const ring = nameRow.createDiv({ cls: "progress-ring-small" });
      ring.innerHTML = this.createProgressRingSVG(progress, 16);
      ring.title = `${streak}/${habit.goalDays} days to goal`;
    }
    if (streak > 0) {
      const streakBadge = info.createEl("span", {
        cls: "habit-streak",
        text: `\u{1F525} ${streak} day${streak > 1 ? "s" : ""}`
      });
      if (streak === 7 || streak === 30 || streak === 100 || streak === 365) {
        streakBadge.addClass("milestone");
      }
    }
    item.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      this.showHabitMenu(e, habit);
    });
  }
  createProgressRingSVG(percentage, size) {
    const strokeWidth = 2;
    const radius = (size - strokeWidth) / 2;
    const circumference = radius * 2 * Math.PI;
    const offset = circumference - percentage / 100 * circumference;
    return `
      <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
        <circle
          cx="${size / 2}" cy="${size / 2}" r="${radius}"
          fill="none"
          stroke="var(--background-modifier-border)"
          stroke-width="${strokeWidth}"
        />
        <circle
          cx="${size / 2}" cy="${size / 2}" r="${radius}"
          fill="none"
          stroke="var(--interactive-accent)"
          stroke-width="${strokeWidth}"
          stroke-dasharray="${circumference}"
          stroke-dashoffset="${offset}"
          stroke-linecap="round"
          transform="rotate(-90 ${size / 2} ${size / 2})"
        />
      </svg>
    `;
  }
  showCompletionAnimation() {
    const confetti = document.createElement("div");
    confetti.className = "confetti-container";
    confetti.innerHTML = "\u{1F389}";
    document.body.appendChild(confetti);
    setTimeout(() => confetti.remove(), 1e3);
  }
  showBadgeEarnedAnimation(badge, habit) {
    const milestone = BADGE_MILESTONES.find((m) => m.type === badge.type);
    if (!milestone)
      return;
    const overlay = document.createElement("div");
    overlay.className = "badge-earned-overlay";
    overlay.innerHTML = `
      <div class="badge-earned-content">
        <div class="badge-earned-emoji">${milestone.emoji}</div>
        <div class="badge-earned-title">Badge Earned!</div>
        <div class="badge-earned-name">${milestone.label}</div>
        <div class="badge-earned-habit">${habit.emoji || ""} ${habit.name}</div>
        <div class="badge-earned-streak">${milestone.days} day streak!</div>
      </div>
    `;
    document.body.appendChild(overlay);
    overlay.addEventListener("click", () => overlay.remove());
    setTimeout(() => overlay.remove(), 3e3);
  }
  renderCalendarView(container) {
    const habits = this.plugin.dataService.getHabits();
    if (habits.length === 0) {
      container.createEl("p", {
        cls: "habit-empty",
        text: "No habits yet. Add a habit to see your calendar!"
      });
      return;
    }
    const nav = container.createDiv({ cls: "calendar-nav" });
    const prevBtn = nav.createEl("button", { text: "\u2039", cls: "nav-btn" });
    prevBtn.addEventListener("click", () => {
      this.currentDate.setMonth(this.currentDate.getMonth() - 1);
      this.render();
    });
    nav.createEl("span", {
      cls: "calendar-month",
      text: this.currentDate.toLocaleDateString("en-US", {
        month: "long",
        year: "numeric"
      })
    });
    const nextBtn = nav.createEl("button", { text: "\u203A", cls: "nav-btn" });
    nextBtn.addEventListener("click", () => {
      this.currentDate.setMonth(this.currentDate.getMonth() + 1);
      this.render();
    });
    const selector = container.createDiv({ cls: "calendar-habit-selector" });
    if (!this.selectedHabitForCalendar) {
      this.selectedHabitForCalendar = habits[0].id;
    }
    habits.forEach((habit) => {
      const btn = selector.createEl("button", {
        cls: `calendar-habit-btn ${this.selectedHabitForCalendar === habit.id ? "active" : ""}`,
        text: (habit.emoji || "\u2022") + " " + habit.name
      });
      btn.addEventListener("click", () => {
        this.selectedHabitForCalendar = habit.id;
        this.render();
      });
    });
    const heatmap = container.createDiv({ cls: "calendar-heatmap" });
    this.renderHeatmap(heatmap, this.selectedHabitForCalendar);
    const legend = container.createDiv({ cls: "calendar-legend" });
    legend.createEl("span", { text: "\u2713 Completed", cls: "legend-item completed" });
    legend.createEl("span", { text: "\u2744\uFE0F Frozen", cls: "legend-item frozen" });
    legend.createEl("span", { text: "\u25CB Missed", cls: "legend-item missed" });
  }
  renderHeatmap(container, habitId) {
    var _a;
    container.empty();
    const year = this.currentDate.getFullYear();
    const month = this.currentDate.getMonth();
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const startOffset = firstDay.getDay();
    const dayLabels = container.createDiv({ cls: "heatmap-days" });
    ["S", "M", "T", "W", "T", "F", "S"].forEach((d) => {
      dayLabels.createEl("span", { text: d });
    });
    const grid = container.createDiv({ cls: "heatmap-grid" });
    for (let i = 0; i < startOffset; i++) {
      grid.createDiv({ cls: "heatmap-cell empty" });
    }
    const todayStr = formatDate(/* @__PURE__ */ new Date());
    for (let day = 1; day <= lastDay.getDate(); day++) {
      const date = new Date(year, month, day);
      const dateStr = formatDate(date);
      const log = this.plugin.dataService.getLog(habitId, dateStr);
      const isCompleted = (_a = log == null ? void 0 : log.completed) != null ? _a : false;
      const isToday = dateStr === todayStr;
      const isFuture = date > /* @__PURE__ */ new Date();
      const isFrozen = this.plugin.dataService.isFrozen(dateStr);
      const cell = grid.createDiv({
        cls: `heatmap-cell ${isCompleted ? "completed" : ""} ${isToday ? "today" : ""} ${isFuture ? "future" : ""} ${isFrozen ? "frozen" : ""}`
      });
      if (isFrozen && !isCompleted) {
        cell.createEl("span", { text: "\u2744\uFE0F", cls: "cell-icon" });
      } else {
        cell.createEl("span", { text: String(day) });
      }
      if (!isFuture) {
        cell.addEventListener("click", async () => {
          await this.plugin.dataService.toggleHabit(habitId, dateStr);
          this.render();
          this.plugin.updateStatusBar();
        });
        cell.addEventListener("contextmenu", async (e) => {
          e.preventDefault();
          if (isFrozen) {
            await this.plugin.dataService.removeFreezeDay(dateStr);
          } else {
            await this.plugin.dataService.addFreezeDay(dateStr);
          }
          this.render();
        });
      }
    }
  }
  renderStatsView(container) {
    const habits = this.plugin.dataService.getHabits();
    if (habits.length === 0) {
      container.createEl("p", {
        cls: "habit-empty",
        text: "No habits yet. Add a habit to see your stats!"
      });
      return;
    }
    const overall = container.createDiv({ cls: "stats-overall" });
    overall.createEl("h3", { text: "Overview" });
    const statsGrid = overall.createDiv({ cls: "stats-grid" });
    this.renderStatCard(statsGrid, "Active Habits", String(habits.length), "\u{1F3AF}");
    const totalCompletions = habits.reduce(
      (sum, h) => sum + this.plugin.dataService.getTotalCompletions(h.id),
      0
    );
    this.renderStatCard(statsGrid, "Total Check-ins", String(totalCompletions), "\u2713");
    const bestStreak = Math.max(0, ...habits.map((h) => this.plugin.dataService.getLongestStreak(h.id)));
    this.renderStatCard(statsGrid, "Best Streak", `${bestStreak} days`, "\u{1F525}");
    const avgRate = habits.length > 0 ? habits.reduce((sum, h) => sum + this.plugin.dataService.getCompletionRate(h.id, 7), 0) / habits.length : 0;
    this.renderStatCard(statsGrid, "7-Day Average", `${avgRate.toFixed(0)}%`, "\u{1F4C8}");
    const totalBadges = this.plugin.dataService.getBadges().length;
    this.renderStatCard(statsGrid, "Badges Earned", String(totalBadges), "\u{1F3C6}");
    const freezesUsed = this.plugin.dataService.getFreezeDaysThisMonth();
    this.renderStatCard(statsGrid, "Freezes Used", `${freezesUsed}/2`, "\u2744\uFE0F");
    if (habits.length > 0) {
      const chartSection = container.createDiv({ cls: "stats-chart-section" });
      chartSection.createEl("h3", { text: "Best Days of the Week" });
      const dayStats = [0, 0, 0, 0, 0, 0, 0];
      habits.forEach((h) => {
        const stats = this.plugin.dataService.getDayOfWeekStats(h.id, 90);
        stats.forEach((val, i) => dayStats[i] += val);
      });
      dayStats.forEach((val, i) => dayStats[i] = dayStats[i] / habits.length);
      this.renderDayOfWeekChart(chartSection, dayStats);
    }
    const perHabit = container.createDiv({ cls: "stats-per-habit" });
    perHabit.createEl("h3", { text: "By Habit" });
    habits.forEach((habit) => {
      const card = perHabit.createDiv({ cls: "habit-stat-card" });
      const header = card.createDiv({ cls: "habit-stat-header" });
      header.createEl("span", {
        cls: "habit-stat-name",
        text: (habit.emoji || "\u2022") + " " + habit.name
      });
      const badges = this.plugin.dataService.getBadges(habit.id);
      if (badges.length > 0) {
        const badgeRow = header.createDiv({ cls: "habit-badges-inline" });
        badges.forEach((b) => {
          const milestone = BADGE_MILESTONES.find((m) => m.type === b.type);
          if (milestone) {
            badgeRow.createEl("span", { text: milestone.emoji, title: milestone.label });
          }
        });
      }
      const metrics = card.createDiv({ cls: "habit-stat-metrics" });
      const currentStreak = this.plugin.dataService.getCurrentStreakWithFreeze(habit.id);
      const longestStreak = this.plugin.dataService.getLongestStreak(habit.id);
      const rate7 = this.plugin.dataService.getCompletionRate(habit.id, 7);
      const rate30 = this.plugin.dataService.getCompletionRate(habit.id, 30);
      metrics.createEl("div", { cls: "habit-stat-metric", text: `Current: ${currentStreak} days` });
      metrics.createEl("div", { cls: "habit-stat-metric", text: `Best: ${longestStreak} days` });
      metrics.createEl("div", { cls: "habit-stat-metric", text: `7d: ${rate7.toFixed(0)}%` });
      metrics.createEl("div", { cls: "habit-stat-metric", text: `30d: ${rate30.toFixed(0)}%` });
    });
  }
  renderDayOfWeekChart(container, dayStats) {
    const chart = container.createDiv({ cls: "day-chart" });
    const days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    const maxVal = Math.max(...dayStats, 1);
    days.forEach((day, i) => {
      const bar = chart.createDiv({ cls: "day-bar" });
      const fill = bar.createDiv({ cls: "day-bar-fill" });
      fill.style.height = `${dayStats[i] / maxVal * 100}%`;
      bar.createEl("span", { cls: "day-label", text: day });
      bar.createEl("span", { cls: "day-value", text: `${dayStats[i].toFixed(0)}%` });
    });
  }
  renderStatCard(container, label, value, icon) {
    const card = container.createDiv({ cls: "stat-card" });
    card.createEl("div", { cls: "stat-icon", text: icon });
    card.createEl("div", { cls: "stat-value", text: value });
    card.createEl("div", { cls: "stat-label", text: label });
  }
  renderBadgesView(container) {
    const allBadges = this.plugin.dataService.getAllBadgesWithDetails();
    container.createEl("h2", { text: "\u{1F3C6} Achievement Gallery", cls: "badges-title" });
    if (allBadges.length === 0) {
      const emptyState = container.createDiv({ cls: "badges-empty" });
      emptyState.createEl("div", { cls: "badges-empty-icon", text: "\u{1F3C6}" });
      emptyState.createEl("p", { text: "No badges earned yet." });
      emptyState.createEl("p", { cls: "badges-empty-hint", text: "Keep up your streaks to earn badges!" });
      const available = container.createDiv({ cls: "badges-available" });
      available.createEl("h3", { text: "Badges to Earn" });
      const badgeGrid2 = available.createDiv({ cls: "badge-grid" });
      BADGE_MILESTONES.forEach((milestone) => {
        const badge = badgeGrid2.createDiv({ cls: "badge-item locked" });
        badge.createEl("div", { cls: "badge-emoji", text: milestone.emoji });
        badge.createEl("div", { cls: "badge-name", text: milestone.label });
        badge.createEl("div", { cls: "badge-requirement", text: `${milestone.days} day streak` });
      });
      return;
    }
    const earned = container.createDiv({ cls: "badges-earned" });
    earned.createEl("h3", { text: `Earned (${allBadges.length})` });
    const badgeGrid = earned.createDiv({ cls: "badge-grid" });
    allBadges.forEach(({ badge, habit, milestone }) => {
      const badgeEl = badgeGrid.createDiv({ cls: "badge-item earned" });
      badgeEl.createEl("div", { cls: "badge-emoji", text: milestone.emoji });
      badgeEl.createEl("div", { cls: "badge-name", text: milestone.label });
      badgeEl.createEl("div", { cls: "badge-habit", text: ((habit == null ? void 0 : habit.emoji) || "") + " " + ((habit == null ? void 0 : habit.name) || "Unknown") });
      badgeEl.createEl("div", { cls: "badge-date", text: new Date(badge.earnedAt).toLocaleDateString() });
    });
    const habits = this.plugin.dataService.getHabits();
    const earnedTypes = new Set(allBadges.map((b) => `${b.badge.habitId}-${b.badge.type}`));
    const remaining = [];
    habits.forEach((habit) => {
      const streak = this.plugin.dataService.getCurrentStreakWithFreeze(habit.id);
      BADGE_MILESTONES.forEach((milestone) => {
        if (!earnedTypes.has(`${habit.id}-${milestone.type}`)) {
          remaining.push({
            habit,
            milestone,
            progress: Math.min(100, streak / milestone.days * 100)
          });
        }
      });
    });
    if (remaining.length > 0) {
      const inProgress = container.createDiv({ cls: "badges-in-progress" });
      inProgress.createEl("h3", { text: "In Progress" });
      const progressGrid = inProgress.createDiv({ cls: "badge-grid" });
      remaining.sort((a, b) => b.progress - a.progress).slice(0, 8).forEach(({ habit, milestone, progress }) => {
        const badgeEl = progressGrid.createDiv({ cls: "badge-item in-progress" });
        badgeEl.createEl("div", { cls: "badge-emoji", text: milestone.emoji });
        badgeEl.createEl("div", { cls: "badge-name", text: milestone.label });
        badgeEl.createEl("div", { cls: "badge-habit", text: (habit.emoji || "") + " " + habit.name });
        const progressBar = badgeEl.createDiv({ cls: "badge-progress-bar" });
        progressBar.createDiv({ cls: "badge-progress-fill", attr: { style: `width: ${progress}%` } });
        badgeEl.createEl("div", { cls: "badge-progress-text", text: `${progress.toFixed(0)}%` });
      });
    }
  }
  showTemplatesModal() {
    const modal = this.plugin.app.workspace.containerEl.createDiv({ cls: "habit-modal-overlay" });
    const dialog = modal.createDiv({ cls: "habit-modal templates-modal" });
    dialog.createEl("h3", { text: "\u{1F4E6} Habit Templates" });
    dialog.createEl("p", { cls: "modal-subtitle", text: "Start with a pre-built habit stack" });
    const templateList = dialog.createDiv({ cls: "template-list" });
    Object.entries(HABIT_TEMPLATES).forEach(([key, template]) => {
      const item = templateList.createDiv({ cls: "template-item" });
      const header = item.createDiv({ cls: "template-header" });
      header.createEl("span", { cls: "template-name", text: template.name });
      header.createEl("span", { cls: "template-count", text: `${template.habits.length} habits` });
      const habits = item.createDiv({ cls: "template-habits" });
      template.habits.forEach((h) => {
        habits.createEl("span", { cls: "template-habit", text: `${h.emoji} ${h.name}` });
      });
      const installBtn = item.createEl("button", { cls: "btn-primary", text: "Install" });
      installBtn.addEventListener("click", async () => {
        const category = await this.plugin.dataService.addCategory(
          template.name.replace(/[^\w\s]/g, "").trim(),
          void 0,
          template.name.split(" ")[0]
        );
        for (const h of template.habits) {
          await this.plugin.dataService.addHabit(h.name, "daily", {
            emoji: h.emoji,
            categoryId: category.id
          });
        }
        modal.remove();
        this.render();
        new import_obsidian2.Notice(`Installed ${template.name} with ${template.habits.length} habits!`);
      });
    });
    const closeBtn = dialog.createEl("button", { cls: "btn-secondary close-btn", text: "Close" });
    closeBtn.addEventListener("click", () => modal.remove());
    modal.addEventListener("click", (e) => {
      if (e.target === modal)
        modal.remove();
    });
  }
  showAddHabitModal() {
    const modal = this.plugin.app.workspace.containerEl.createDiv({ cls: "habit-modal-overlay" });
    const dialog = modal.createDiv({ cls: "habit-modal" });
    dialog.createEl("h3", { text: "New Habit" });
    const form = dialog.createEl("form");
    const nameGroup = form.createDiv({ cls: "form-group" });
    nameGroup.createEl("label", { text: "Habit name" });
    const nameInput = nameGroup.createEl("input", {
      type: "text",
      placeholder: "e.g., Exercise, Read, Meditate"
    });
    const emojiGroup = form.createDiv({ cls: "form-group" });
    emojiGroup.createEl("label", { text: "Emoji (optional)" });
    const emojiInput = emojiGroup.createEl("input", {
      type: "text",
      placeholder: "e.g., \u{1F3C3} \u{1F4DA} \u{1F9D8}"
    });
    const categories = this.plugin.dataService.getCategories();
    const categoryGroup = form.createDiv({ cls: "form-group" });
    categoryGroup.createEl("label", { text: "Category (optional)" });
    const categorySelect = categoryGroup.createEl("select");
    categorySelect.createEl("option", { value: "", text: "No category" });
    categories.forEach((cat) => {
      categorySelect.createEl("option", { value: cat.id, text: (cat.emoji || "") + " " + cat.name });
    });
    const newCatContainer = categoryGroup.createDiv({ cls: "new-category-container" });
    const newCatBtn = newCatContainer.createEl("button", { type: "button", cls: "btn-link", text: "+ New Category" });
    const newCatInputRow = newCatContainer.createDiv({ cls: "new-category-input-row hidden" });
    const newCatInput = newCatInputRow.createEl("input", { type: "text", placeholder: "Category name" });
    const newCatSaveBtn = newCatInputRow.createEl("button", { type: "button", cls: "btn btn-small", text: "Add" });
    const newCatCancelBtn = newCatInputRow.createEl("button", { type: "button", cls: "btn btn-small btn-secondary", text: "Cancel" });
    newCatBtn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      newCatBtn.addClass("hidden");
      newCatInputRow.removeClass("hidden");
      newCatInput.focus();
    });
    newCatCancelBtn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      newCatInputRow.addClass("hidden");
      newCatBtn.removeClass("hidden");
      newCatInput.value = "";
    });
    const saveNewCategory = async () => {
      const name = newCatInput.value.trim();
      if (name) {
        const cat = await this.plugin.dataService.addCategory(name);
        categorySelect.createEl("option", { value: cat.id, text: cat.name });
        categorySelect.value = cat.id;
        newCatInput.value = "";
        newCatInputRow.addClass("hidden");
        newCatBtn.removeClass("hidden");
      }
    };
    newCatSaveBtn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      saveNewCategory();
    });
    newCatInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        e.stopPropagation();
        saveNewCategory();
      } else if (e.key === "Escape") {
        e.preventDefault();
        newCatInputRow.addClass("hidden");
        newCatBtn.removeClass("hidden");
        newCatInput.value = "";
      }
    });
    const freqGroup = form.createDiv({ cls: "form-group" });
    freqGroup.createEl("label", { text: "Frequency" });
    const freqSelect = freqGroup.createEl("select");
    freqSelect.createEl("option", { value: "daily", text: "Daily" });
    freqSelect.createEl("option", { value: "weekly", text: "Weekly" });
    freqSelect.createEl("option", { value: "custom", text: "Custom days" });
    const customDaysGroup = form.createDiv({ cls: "form-group custom-days hidden" });
    customDaysGroup.createEl("label", { text: "Select days" });
    const daysContainer = customDaysGroup.createDiv({ cls: "days-selector" });
    const days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    const selectedDays = [];
    days.forEach((day, index) => {
      const dayBtn = daysContainer.createEl("button", { type: "button", cls: "day-btn", text: day });
      dayBtn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (selectedDays.includes(index)) {
          selectedDays.splice(selectedDays.indexOf(index), 1);
          dayBtn.removeClass("active");
        } else {
          selectedDays.push(index);
          dayBtn.addClass("active");
        }
      });
    });
    freqSelect.addEventListener("change", () => {
      if (freqSelect.value === "custom" || freqSelect.value === "weekly") {
        customDaysGroup.removeClass("hidden");
      } else {
        customDaysGroup.addClass("hidden");
      }
    });
    const goalGroup = form.createDiv({ cls: "form-group" });
    goalGroup.createEl("label", { text: "Goal (optional)" });
    const goalSelect = goalGroup.createEl("select");
    goalSelect.createEl("option", { value: "", text: "No goal" });
    goalSelect.createEl("option", { value: "7", text: "\u{1F525} 7-day streak" });
    goalSelect.createEl("option", { value: "30", text: "\u2B50 30-day streak" });
    goalSelect.createEl("option", { value: "100", text: "\u{1F48E} 100-day streak" });
    goalSelect.createEl("option", { value: "365", text: "\u{1F451} 365-day streak" });
    const buttons = form.createDiv({ cls: "form-buttons" });
    const cancelBtn = buttons.createEl("button", { type: "button", cls: "btn-secondary", text: "Cancel" });
    cancelBtn.addEventListener("click", () => modal.remove());
    buttons.createEl("button", { type: "submit", cls: "btn-primary", text: "Create Habit" });
    form.addEventListener("submit", async (e) => {
      e.preventDefault();
      const name = nameInput.value.trim();
      if (!name) {
        new import_obsidian2.Notice("Please enter a habit name");
        return;
      }
      await this.plugin.dataService.addHabit(
        name,
        freqSelect.value,
        {
          emoji: emojiInput.value.trim() || void 0,
          customDays: selectedDays.length > 0 ? selectedDays : void 0,
          categoryId: categorySelect.value || void 0,
          goalDays: goalSelect.value ? parseInt(goalSelect.value) : void 0
        }
      );
      modal.remove();
      this.render();
      this.plugin.updateStatusBar();
      new import_obsidian2.Notice(`Habit "${name}" created!`);
    });
    modal.addEventListener("click", (e) => {
      if (e.target === modal)
        modal.remove();
    });
    nameInput.focus();
  }
  showHabitMenu(event, habit) {
    const menu = new import_obsidian2.Menu();
    menu.addItem(
      (item) => item.setTitle("Edit").setIcon("pencil").onClick(() => this.showEditHabitModal(habit))
    );
    const categories = this.plugin.dataService.getCategories();
    if (categories.length > 0) {
      menu.addItem(
        (item) => item.setTitle("Move to Category").setIcon("folder").onClick(() => {
          const catMenu = new import_obsidian2.Menu();
          catMenu.addItem((i) => i.setTitle("No category").onClick(async () => {
            await this.plugin.dataService.updateHabit(habit.id, { categoryId: void 0 });
            this.render();
          }));
          categories.forEach((cat) => {
            catMenu.addItem((i) => i.setTitle((cat.emoji || "") + " " + cat.name).onClick(async () => {
              await this.plugin.dataService.updateHabit(habit.id, { categoryId: cat.id });
              this.render();
            }));
          });
          catMenu.showAtMouseEvent(event);
        })
      );
    }
    menu.addItem(
      (item) => item.setTitle("Archive").setIcon("archive").onClick(async () => {
        await this.plugin.dataService.archiveHabit(habit.id);
        this.render();
        new import_obsidian2.Notice(`"${habit.name}" archived`);
      })
    );
    menu.addSeparator();
    menu.addItem(
      (item) => item.setTitle("Delete").setIcon("trash").onClick(async () => {
        if (confirm(`Delete "${habit.name}"? This cannot be undone.`)) {
          await this.plugin.dataService.deleteHabit(habit.id);
          this.render();
          this.plugin.updateStatusBar();
          new import_obsidian2.Notice(`"${habit.name}" deleted`);
        }
      })
    );
    menu.showAtMouseEvent(event);
  }
  showEditHabitModal(habit) {
    const modal = this.plugin.app.workspace.containerEl.createDiv({ cls: "habit-modal-overlay" });
    const dialog = modal.createDiv({ cls: "habit-modal" });
    dialog.createEl("h3", { text: "Edit Habit" });
    const form = dialog.createEl("form");
    const nameGroup = form.createDiv({ cls: "form-group" });
    nameGroup.createEl("label", { text: "Habit name" });
    const nameInput = nameGroup.createEl("input", { type: "text", value: habit.name });
    const emojiGroup = form.createDiv({ cls: "form-group" });
    emojiGroup.createEl("label", { text: "Emoji" });
    const emojiInput = emojiGroup.createEl("input", { type: "text", value: habit.emoji || "" });
    const categories = this.plugin.dataService.getCategories();
    const categoryGroup = form.createDiv({ cls: "form-group" });
    categoryGroup.createEl("label", { text: "Category" });
    const categorySelect = categoryGroup.createEl("select");
    categorySelect.createEl("option", { value: "", text: "No category" });
    categories.forEach((cat) => {
      const opt = categorySelect.createEl("option", { value: cat.id, text: (cat.emoji || "") + " " + cat.name });
      if (habit.categoryId === cat.id)
        opt.selected = true;
    });
    const goalGroup = form.createDiv({ cls: "form-group" });
    goalGroup.createEl("label", { text: "Goal" });
    const goalSelect = goalGroup.createEl("select");
    goalSelect.createEl("option", { value: "", text: "No goal" });
    [7, 30, 100, 365].forEach((days) => {
      const opt = goalSelect.createEl("option", { value: String(days), text: `${days}-day streak` });
      if (habit.goalDays === days)
        opt.selected = true;
    });
    const buttons = form.createDiv({ cls: "form-buttons" });
    const cancelBtn = buttons.createEl("button", { type: "button", cls: "btn-secondary", text: "Cancel" });
    cancelBtn.addEventListener("click", () => modal.remove());
    buttons.createEl("button", { type: "submit", cls: "btn-primary", text: "Save Changes" });
    form.addEventListener("submit", async (e) => {
      e.preventDefault();
      const name = nameInput.value.trim();
      if (!name) {
        new import_obsidian2.Notice("Please enter a habit name");
        return;
      }
      await this.plugin.dataService.updateHabit(habit.id, {
        name,
        emoji: emojiInput.value.trim() || void 0,
        categoryId: categorySelect.value || void 0,
        goalDays: goalSelect.value ? parseInt(goalSelect.value) : void 0
      });
      modal.remove();
      this.render();
      new import_obsidian2.Notice("Habit updated!");
    });
    modal.addEventListener("click", (e) => {
      if (e.target === modal)
        modal.remove();
    });
    nameInput.focus();
  }
};

// main.ts
var HabitTrackerPlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.statusBarItem = null;
  }
  async onload() {
    console.log("Loading Habit Tracker plugin");
    this.dataService = new DataService(this);
    await this.dataService.load();
    await this.loadSettings();
    this.registerView(HABIT_VIEW_TYPE, (leaf) => new HabitView(leaf, this));
    this.addRibbonIcon("check-circle", "Habit Tracker", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-habit-tracker",
      name: "Open Habit Tracker",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "toggle-habit",
      name: "Quick toggle habit",
      callback: () => {
        this.showQuickToggle();
      }
    });
    if (this.settings.showInStatusBar) {
      this.statusBarItem = this.addStatusBarItem();
      this.updateStatusBar();
    }
    this.addSettingTab(new HabitTrackerSettingTab(this.app, this));
    this.app.workspace.onLayoutReady(() => {
      const existing = this.app.workspace.getLeavesOfType(HABIT_VIEW_TYPE);
      if (existing.length === 0) {
      }
    });
  }
  async onunload() {
    console.log("Unloading Habit Tracker plugin");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(HABIT_VIEW_TYPE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: HABIT_VIEW_TYPE, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  updateStatusBar() {
    if (!this.statusBarItem) {
      if (this.settings.showInStatusBar) {
        this.statusBarItem = this.addStatusBarItem();
      } else {
        return;
      }
    }
    if (!this.settings.showInStatusBar) {
      this.statusBarItem.remove();
      this.statusBarItem = null;
      return;
    }
    const today = /* @__PURE__ */ new Date();
    const dateStr = formatDate(today);
    const habits = this.dataService.getHabits();
    const dueToday = habits.filter((h) => isHabitDueOnDate(h, today));
    const completedToday = dueToday.filter((h) => {
      const log = this.dataService.getLog(h.id, dateStr);
      return log == null ? void 0 : log.completed;
    });
    const text = dueToday.length > 0 ? `\u2713 ${completedToday.length}/${dueToday.length}` : "\u2713 No habits";
    this.statusBarItem.setText(text);
    this.statusBarItem.setAttr(
      "title",
      `Habits: ${completedToday.length} of ${dueToday.length} completed today`
    );
    this.statusBarItem.addClass("mod-clickable");
    this.statusBarItem.onClickEvent(() => {
      this.activateView();
    });
  }
  refreshViews() {
    const leaves = this.app.workspace.getLeavesOfType(HABIT_VIEW_TYPE);
    leaves.forEach((leaf) => {
      const view = leaf.view;
      if (view && view.render) {
        view.render();
      }
    });
    this.updateStatusBar();
  }
  showQuickToggle() {
    const today = /* @__PURE__ */ new Date();
    const dateStr = formatDate(today);
    const habits = this.dataService.getHabits();
    const dueToday = habits.filter((h) => isHabitDueOnDate(h, today));
    if (dueToday.length === 0) {
      return;
    }
    const incomplete = dueToday.find((h) => {
      const log = this.dataService.getLog(h.id, dateStr);
      return !(log == null ? void 0 : log.completed);
    });
    if (incomplete) {
      this.dataService.toggleHabit(incomplete.id, dateStr).then(() => {
        this.refreshViews();
      });
    }
  }
};
